-- Copyright (c) 2018 Scott Morrison. All rights reserved.
-- Released under Apache 2.0 license as described in the file LICENSE.
-- Authors: Scott Morrison

import .natural_transformation
import .heterogeneous_identity
import data.fintype

namespace categories

universes u‚ÇÅ u‚ÇÇ

class small (C : Type (u‚ÇÅ+1)) :=
(model : Type u‚ÇÅ)
(smallness : equiv C model)

instance ulift_small (Œ± : Type u‚ÇÅ) : small (ulift.{u‚ÇÅ+1 u‚ÇÅ} Œ±) := 
{ model := Œ±, 
  smallness := { to_fun    := ulift.down,
                 inv_fun   := ulift.up,
                 left_inv  := sorry,
                 right_inv := sorry } }

-- PROJECT: seems hard without choice
-- instance (Œ± : Type (u+1)) [fintype Œ±] : small Œ± := 

-- PROJECT: tactics for deriving instances of small, e.g. `small pempty`!

class small_category (C : Type (u‚ÇÅ+1)) extends category C, small C.

def down {C : Type (u‚ÇÅ+1)} [small C] (X : C)             := (small.smallness C).to_fun  X
def up   {C : Type (u‚ÇÅ+1)} [small C] (X : small.model C) := (small.smallness C).inv_fun X

@[simp,ematch] lemma up_down {C : Type (u‚ÇÅ+1)} [small C] (X : C)             : up (down X) = X := (small.smallness C).left_inv X
@[simp,ematch] lemma down_up {C : Type (u‚ÇÅ+1)} [small C] (X : small.model C) : down (up X) = X := (small.smallness C).right_inv X

@[reducible] def small_hom {C : Type (u‚ÇÅ+1)} [small_category C] {X Y : C} (f : X ‚ü∂ Y) : up (down X) ‚ü∂ up (down Y) := (h_identity (by simp)) ‚â´ f ‚â´ (h_identity (by simp))
@[reducible] def large_hom {C : Type (u‚ÇÅ+1)} [small_category C] {X Y : C} (f : up (down X) ‚ü∂ up (down Y)) : X ‚ü∂ Y := (h_identity (by simp)) ‚â´ f ‚â´ (h_identity (by simp))

notation `ùüô‚Çõ` X : 16 := category.identity (up X)   -- type as \b1
notation X ` ‚ü∂‚Çõ ` Y : 9 := category.Hom (up X) (up Y)    -- type as \h

namespace functor

structure small_Functor (C : Type (u‚ÇÅ+1)) [small_category C] (D : Type (u‚ÇÇ+1)) [category D] : Type (max u‚ÇÅ u‚ÇÇ+1) :=
  (onSmallObjects     : small.model C ‚Üí D)
  (onSmallMorphisms   : Œ† {X Y : small.model C}, (X ‚ü∂‚Çõ Y) ‚Üí ((onSmallObjects X) ‚ü∂ (onSmallObjects Y)))
  (identities'    : ‚àÄ (X : small.model C), onSmallMorphisms (ùüô‚Çõ X) = ùüô (onSmallObjects X) . obviously)
  (functoriality' : ‚àÄ {X Y Z : small.model C} (f : X ‚ü∂‚Çõ Y) (g : Y ‚ü∂‚Çõ Z), onSmallMorphisms (f ‚â´ g) = (onSmallMorphisms f) ‚â´ (onSmallMorphisms g) . obviously)

infixr ` ‚Üù‚Çõ `:70 := small_Functor -- type as \lea 

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÇ+1)} [category D] (F : C ‚Üù‚Çõ D)
def small_Functor.onObjects   (X : C) := F.onSmallObjects (down X)
def small_Functor.onMorphisms {X Y : C} (f : X ‚ü∂ Y) : F.onObjects X ‚ü∂ F.onObjects Y := F.onSmallMorphisms (small_hom f)

@[simp,ematch] lemma small_Functor.identities (X : C) : F.onMorphisms (ùüô X) = ùüô (F.onObjects X) := sorry
@[simp,ematch] lemma small_Functor.functoriality {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : F.onMorphisms (f ‚â´ g) = (F.onMorphisms f) ‚â´ (F.onMorphisms g) := sorry

@[simp,ematch] lemma small_Functor.h_identities (X Y : C) (p : X = Y) : F.onMorphisms (h_identity p) = h_identity (congr_arg F.onObjects p) :=
begin
  induction p,
  tidy,
end
end

infixr ` +>‚Çõ `:69 := small_Functor.onObjects
infixr ` &>‚Çõ `:69 := small_Functor.onMorphisms -- switch to ‚ñπ?

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] 

def small_Functor.up (F : C ‚Üù‚Çõ D) : C ‚Üù D :=
{ onObjects := Œª X, F +>‚Çõ X,
  onMorphisms := Œª X Y f, F &>‚Çõ f, }

@[simp] lemma small_Functor.up_onObjects   (F : C ‚Üù‚Çõ D) (X : C) : F.up +> X = F +>‚Çõ X := by refl
@[simp] lemma small_Functor.up_onMorphisms (F : C ‚Üù‚Çõ D) {X Y : C} (f : X ‚ü∂ Y) : F.up &> f = F &>‚Çõ f := by refl

def Functor.down (F : C ‚Üù D) : C ‚Üù‚Çõ D :=
{ onSmallObjects := Œª X, F +> (up X),
  onSmallMorphisms := Œª _ _ f, F &> f, }

@[simp] lemma Functor.down_onObjects   (F : C ‚Üù D) (X : C) : F.down +>‚Çõ X = F +> X := sorry
@[simp] lemma Functor.down_onMorphisms (F : C ‚Üù D) {X Y : C} (f : X ‚ü∂ Y) : F.down &>‚Çõ f = F &> (small_hom f) := by refl

def Functor.down_up_to_id (F : C ‚Üù D) : F.down.up ‚üπ F := sorry
def Functor.id_to_down_up (F : C ‚Üù D) : F ‚üπ F.down.up := sorry
end

-- set_option pp.all true

structure small_small_Functor (C : Type (u‚ÇÅ+1)) [small_category C] (D : Type (u‚ÇÇ+1)) [small_category D] : Type (max u‚ÇÅ u‚ÇÇ) :=
  (onSmallObjects     : small.model C ‚Üí small.model D)
  (onSmallMorphisms   : Œ† {X Y : small.model C}, (X ‚ü∂‚Çõ Y) ‚Üí (up (onSmallObjects X) ‚ü∂ up (onSmallObjects Y)))
  (identities'    : ‚àÄ (X : small.model C), onSmallMorphisms (ùüô‚Çõ X) = ùüô‚Çõ (onSmallObjects X) . obviously)
  (functoriality' : ‚àÄ {X Y Z : small.model C} (f : X ‚ü∂‚Çõ Y) (g : Y ‚ü∂‚Çõ Z), onSmallMorphisms (f ‚â´ g) = (onSmallMorphisms f) ‚â´ (onSmallMorphisms g) . obviously)

infixr ` ‚Üù‚Çõ‚Çõ `:70 := small_small_Functor -- type as \lea 

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÇ+1)} [small_category D] (F : C ‚Üù‚Çõ‚Çõ D)
def small_small_Functor.onObjects   (X : C) := up (F.onSmallObjects (down X))
def small_small_Functor.onMorphisms {X Y : C} (f : X ‚ü∂ Y) : (F.onObjects X) ‚ü∂ (F.onObjects Y) := F.onSmallMorphisms (small_hom f)

@[simp,ematch] lemma small_small_Functor.identities (X : C) : F.onMorphisms (ùüô X) = ùüô (F.onObjects X) := sorry
@[simp,ematch] lemma small_small_Functor.functoriality {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : F.onMorphisms (f ‚â´ g) = (F.onMorphisms f) ‚â´ (F.onMorphisms g) := sorry

infixr ` +>‚Çõ‚Çõ `:69 := small_small_Functor.onObjects
infixr ` &>‚Çõ‚Çõ `:69 := small_small_Functor.onMorphisms -- switch to ‚ñπ?

def small_small_Functor.up (F : C ‚Üù‚Çõ‚Çõ D) : C ‚Üù‚Çõ D :=
{ onSmallObjects := Œª X, up (F.onSmallObjects X),
  onSmallMorphisms := Œª _ _ f, F.onSmallMorphisms f,
  identities' := Œª X, F.identities' X,
  functoriality' := Œª _ _ _ f g, F.functoriality' f g }

@[simp] lemma small_small_Functor.up_onObjects   (F : C ‚Üù‚Çõ‚Çõ D) (X : C) : F.up +>‚Çõ X = F +>‚Çõ‚Çõ X := by refl
@[simp] lemma small_small_Functor.up_onMorphisms (F : C ‚Üù‚Çõ‚Çõ D) {X Y : C} (f : X ‚ü∂ Y) : F.up &>‚Çõ f = F &>‚Çõ‚Çõ f := by refl

def small_Functor.down (F : C ‚Üù‚Çõ D) : C ‚Üù‚Çõ‚Çõ D :=
{ onSmallObjects   := Œª X, down (F.onSmallObjects X),
  onSmallMorphisms := Œª _ _ f, small_hom (F.onSmallMorphisms f),
  identities'    := sorry,
  functoriality' := sorry, }

@[simp] lemma small_Functor.down_onObjects   (F : C ‚Üù‚Çõ D) (X : C) : F.down +>‚Çõ‚Çõ X = F +>‚Çõ X := sorry
@[simp] lemma small_Functor.down_onMorphisms (F : C ‚Üù‚Çõ D) {X Y : C} (f : X ‚ü∂ Y) : F.down &>‚Çõ‚Çõ f = (h_identity (F.down_onObjects X)) ‚â´ (F &>‚Çõ f) ‚â´ (h_identity (eq.symm (F.down_onObjects Y))) := by refl

instance small_Functor_really_small : small (small_Functor C D) := 
{ model := small_small_Functor C D,
  smallness := {
    to_fun    := Œª F, F.down,
    inv_fun   := Œª F, F.up,
    left_inv  := sorry,
    right_inv := sorry,
  }
}

-- FIXME
-- @[simp,ematch] lemma small_small_Functor.h_identities (X Y : C) (p : X = Y) : F.onMorphisms (h_identity p) = h_identity (congr_arg F.onObjects p) :=
-- begin
--   induction p,
--   tidy,
-- end
end

end functor
 
namespace natural_transformation

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÇ+1)} [category D]

structure small_NaturalTransformation (F G : C ‚Üù‚Çõ D) : Type (max u‚ÇÅ u‚ÇÇ) :=
  (small_components : Œ† X : small.model C, (F.onSmallObjects X) ‚ü∂ (G.onSmallObjects X))
  (naturality'      : ‚àÄ {X Y : small.model C} (f : X ‚ü∂‚Çõ Y), (F.onSmallMorphisms f) ‚â´ (small_components Y) = (small_components X) ‚â´ (G.onSmallMorphisms f) . obviously)

infixr ` ‚üπ‚Çõ `:50  := small_NaturalTransformation             -- type as \==>

variables {F G : C ‚Üù‚Çõ D} 

def small_NaturalTransformation.components (œÑ : F ‚üπ‚Çõ G) (X : C) : (F +>‚Çõ X) ‚ü∂ (G +>‚Çõ X) := œÑ.small_components (down X)
@[ematch] def small_NaturalTransformation.naturality (œÑ : F ‚üπ‚Çõ G) {X Y : C} (f : X ‚ü∂ Y) : (F &>‚Çõ f) ‚â´ (œÑ.components Y) = (œÑ.components X) ‚â´ (G &>‚Çõ f) := sorry
end

@[applicable] lemma small_NaturalTransformations_componentwise_equal
  {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù‚Çõ D)
  (Œ± Œ≤ : F ‚üπ‚Çõ G)
  (w : ‚àÄ X : C, Œ±.components X = Œ≤.components X) : Œ± = Œ≤ :=
  begin
    cases Œ±,
    cases Œ≤,
    have hc : Œ±_small_components = Œ≤_small_components := sorry,
    subst hc
  end

def small_NaturalTransformation.up {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] {F G : C ‚Üù‚Çõ D} (Œ± : F ‚üπ‚Çõ G) : F.up ‚üπ G.up :=
{ components := Œª X, Œ±.components X, }

def NaturalTransformation.down {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] {F G : C ‚Üù D} (Œ± : F ‚üπ G) : F.down ‚üπ‚Çõ G.down :=
{ small_components := Œª X, Œ±.components (up X), }

def small_NaturalTransformation_equiv {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù‚Çõ D) : equiv (F.up ‚üπ G.up) (F ‚üπ‚Çõ G) :=
{ to_fun    := sorry,
  inv_fun   := sorry,
  left_inv  := sorry,
  right_inv := sorry, }

def small_NaturalTransformation_equiv' {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù D) : equiv (F ‚üπ G) (F.down ‚üπ‚Çõ G.down) := sorry

end natural_transformation


end categories