-- Copyright (c) 2018 Scott Morrison. All rights reserved.
-- Released under Apache 2.0 license as described in the file LICENSE.
-- Authors: Scott Morrison

import .natural_transformation
import .heterogeneous_identity
import data.fintype

namespace categories

universes u‚ÇÅ u‚ÇÇ

class small (C : Type (u‚ÇÅ+1)) :=
(model : Type u‚ÇÅ)
(smallness : equiv C model)

instance ulift_small (Œ± : Type u‚ÇÅ) : small (ulift.{u‚ÇÅ+1 u‚ÇÅ} Œ±) := 
{ model := Œ±, 
  smallness := { to_fun    := ulift.down,
                 inv_fun   := ulift.up,
                 left_inv  := sorry,
                 right_inv := sorry } }

-- PROJECT: seems hard without choice
-- instance (Œ± : Type (u+1)) [fintype Œ±] : small Œ± := 

-- PROJECT: tactics for deriving instances of small, e.g. `small pempty`!

class small_category (C : Type (u‚ÇÅ+1)) extends category C, small C.

def down {C : Type (u‚ÇÅ+1)} [small C] (X : C)             := (small.smallness C).to_fun  X
def up   {C : Type (u‚ÇÅ+1)} [small C] (X : small.model C) := (small.smallness C).inv_fun X

@[simp,ematch] lemma up_down {C : Type (u‚ÇÅ+1)} [small C] (X : C)             : up (down X) = X := (small.smallness C).left_inv X
@[simp,ematch] lemma down_up {C : Type (u‚ÇÅ+1)} [small C] (X : small.model C) : down (up X) = X := (small.smallness C).right_inv X

@[reducible] def small_hom {C : Type (u‚ÇÅ+1)} [small_category C] {X Y : C} (f : X ‚ü∂ Y) : up (down X) ‚ü∂ up (down Y) := (h_identity (by simp)) ‚â´ f ‚â´ (h_identity (by simp))
@[reducible] def large_hom {C : Type (u‚ÇÅ+1)} [small_category C] {X Y : C} (f : up (down X) ‚ü∂ up (down Y)) : X ‚ü∂ Y := (h_identity (by simp)) ‚â´ f ‚â´ (h_identity (by simp))

notation `ùüô‚Çõ` X : 16 := category.identity (up X)   -- type as \b1
notation X ` ‚ü∂ ` Y : 9 := category.Hom (up X) (up Y)    -- type as \h

namespace functor

structure small_Functor (C : Type (u‚ÇÅ+1)) [small_category C] (D : Type (u‚ÇÇ+1)) [category D] : Type ((max u‚ÇÅ u‚ÇÇ)+1) :=
  (onSmallObjects     : small.model C ‚Üí D)
  (onSmallMorphisms   : Œ† {X Y : small.model C}, (X ‚ü∂ Y) ‚Üí ((onSmallObjects X) ‚ü∂ (onSmallObjects Y)))
  (identities'    : ‚àÄ (X : small.model C), onSmallMorphisms (ùüô‚Çõ X) = ùüô (onSmallObjects X) . obviously)
  (functoriality' : ‚àÄ {X Y Z : small.model C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), onSmallMorphisms (f ‚â´ g) = (onSmallMorphisms f) ‚â´ (onSmallMorphisms g) . obviously)

infixr ` ‚Üù‚Çõ `:70 := small_Functor -- type as \lea 

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÇ+1)} [category D] (F : C ‚Üù‚Çõ D)
def small_Functor.onObjects   (X : C) := F.onSmallObjects (down X)
def small_Functor.onMorphisms {X Y : C} (f : X ‚ü∂ Y) : F.onObjects X ‚ü∂ F.onObjects Y := F.onSmallMorphisms (small_hom f)

@[simp,ematch] lemma small_Functor.identities (X : C) : F.onMorphisms (ùüô X) = ùüô (F.onObjects X) := sorry
@[simp,ematch] lemma small_Functor.functoriality {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : F.onMorphisms (f ‚â´ g) = (F.onMorphisms f) ‚â´ (F.onMorphisms g) := sorry

@[simp,ematch] lemma small_Functor.h_identities (X Y : C) (p : X = Y) : F.onMorphisms (h_identity p) = h_identity (congr_arg F.onObjects p) :=
begin
  induction p,
  tidy,
end

end

infixr ` +>‚Çõ `:69 := small_Functor.onObjects
infixr ` &>‚Çõ `:69 := small_Functor.onMorphisms -- switch to ‚ñπ?

variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] 

def small_Functor.up (F : C ‚Üù‚Çõ D) : C ‚Üù D :=
{ onObjects := Œª X, F +>‚Çõ X,
  onMorphisms := Œª X Y f, F &>‚Çõ f, }

@[simp] lemma small_Functor.up.onObjects   (F : C ‚Üù‚Çõ D) (X : C) : F.up +> X = F +>‚Çõ X := by refl
@[simp] lemma small_Functor.up.onMorphisms (F : C ‚Üù‚Çõ D) {X Y : C} (f : X ‚ü∂ Y) : F.up &> f = F &>‚Çõ f := by refl

def Functor.down (F : C ‚Üù D) : C ‚Üù‚Çõ D :=
{ onSmallObjects := Œª X, F +> (up X),
  onSmallMorphisms := Œª _ _ f, F &> f, }

@[simp] lemma Functor.down.onObjects   (F : C ‚Üù D) (X : C) : F.down +>‚Çõ X = F +> X := sorry
@[simp] lemma Functor.down.onMorphisms (F : C ‚Üù D) {X Y : C} (f : X ‚ü∂ Y) : F.down &>‚Çõ f = F &> (small_hom f) := by refl

def Functor.down_up_to_id (F : C ‚Üù D) : F.down.up ‚üπ F := sorry
def Functor.id_to_down_up (F : C ‚Üù D) : F ‚üπ F.down.up := sorry


end functor
 
namespace natural_transformation

section
variables {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D]

structure small_NaturalTransformation (F G : C ‚Üù‚Çõ D) : Type u‚ÇÅ :=
  (small_components : Œ† X : small.model C, (F.onSmallObjects X) ‚ü∂ (G.onSmallObjects X))
  (naturality'      : ‚àÄ {X Y : small.model C} (f : X ‚ü∂ Y), (F.onSmallMorphisms f) ‚â´ (small_components Y) = (small_components X) ‚â´ (G.onSmallMorphisms f) . obviously)

infixr ` ‚üπ‚Çõ `:50  := small_NaturalTransformation             -- type as \==>

variables {F G : C ‚Üù‚Çõ D} 

def small_NaturalTransformation.components (œÑ : F ‚üπ‚Çõ G) (X : C) : (F +>‚Çõ X) ‚ü∂ (G +>‚Çõ X) := œÑ.small_components (down X)
@[ematch] def small_NaturalTransformation.naturality (œÑ : F ‚üπ‚Çõ G) {X Y : C} (f : X ‚ü∂ Y) : (F &>‚Çõ f) ‚â´ (œÑ.components Y) = (œÑ.components X) ‚â´ (G &>‚Çõ f) := sorry
end

@[applicable] lemma small_NaturalTransformations_componentwise_equal
  {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù‚Çõ D)
  (Œ± Œ≤ : F ‚üπ‚Çõ G)
  (w : ‚àÄ X : C, Œ±.components X = Œ≤.components X) : Œ± = Œ≤ :=
  begin
    induction Œ± with Œ±_components Œ±_naturality,
    induction Œ≤ with Œ≤_components Œ≤_naturality,
    have hc : Œ±_components = Œ≤_components := sorry,
    subst hc
  end

def small_NaturalTransformation.up {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] {F G : C ‚Üù‚Çõ D} (Œ± : F ‚üπ‚Çõ G) : F.up ‚üπ G.up :=
{ components := Œª X, Œ±.components X, }

def NaturalTransformation.down {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] {F G : C ‚Üù D} (Œ± : F ‚üπ G) : F.down ‚üπ‚Çõ G.down :=
{ small_components := Œª X, Œ±.components (up X), }

def small_NaturalTransformation_equiv {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù‚Çõ D) : equiv (F.up ‚üπ G.up) (F ‚üπ‚Çõ G) :=
{ to_fun    := sorry,
  inv_fun   := sorry,
  left_inv  := sorry,
  right_inv := sorry, }

def small_NaturalTransformation_equiv' {C : Type (u‚ÇÅ+1)} [small_category C] {D : Type (u‚ÇÅ+1)} [category D] (F G : C ‚Üù D) : equiv (F ‚üπ G) (F.down ‚üπ‚Çõ G.down) := sorry

end natural_transformation


end categories